let examples = {
  "add": "********************************************************************************\n*                                                                              *\n*      (c) 2018 Max Apodaca                                                    *\n*      This code is licensed under MIT license (see LICENSE for details)       *\n*                                                                              *\n********************************************************************************\n\nLDI 12\nSTA 200\nLDI 8\nADD 200\nOUT\nHLT\n",
  "divide": "********************************************************************************\n*                                                                              *\n*      (c) 2018 Max Apodaca                                                    *\n*      This code is licensed under MIT license (see LICENSE for details)       *\n*                                                                              *\n********************************************************************************\n\nLDI 120       * The dividend\nSTA 255\nLDI 10        * The divisor\nSTA 254\nLDI 1         * constant one for subtraction\nSTA 253\nLDI 0         * reset accumulator to zero\nSTA 252\n\ndivide:\nLDA 255       * Load the dividend into the A register\nSUB 254       * subtract divisor\nJGZ skip      * if dividend is zero end the program\nJEZ skip\nJMP end\nskip: STA 255 * save the number\nLDA 252       * load the accumulator\nADD 253       * add one to the accumulator\nSTA 252       * save the result\nJMP divide    * repeat until divisor number to multiply is zero\n\nend:\nLDA 252       * load accumulator\nOUT           * output result\nHLT\n",
  "fibonacci": "********************************************************************************\n*                                                                              *\n*      (c) 2018 Max Apodaca                                                    *\n*      This code is licensed under MIT license (see LICENSE for details)       *\n*                                                                              *\n********************************************************************************\n\nLDI 233     * Load 233, the maximum value\nSTA 253\nLDI 1       * Load 1, the starting value\nOUT         * Set the display to display 1\nSTA 255\nSTA 254\n\nloop:\nADD 255     * Add 255 to compute second digit\nOUT\nSTA 255\nSUB 253     * Subtract 233 to see if we are at the maximum number\nJEZ end     * If we are then jump to end\nLDA 255     * revert to old value\nADD 254     * the next set of instructions repeats the above with the other\nOUT         * register which allows for the previous value to be used.\nSTA 254\nSUB 253\nJEZ end\nLDA 254\nJMP loop\n\nend:\nHLT         * stop execution\n",
  "loop": "********************************************************************************\n*                                                                              *\n*      (c) 2018 Max Apodaca                                                    *\n*      This code is licensed under MIT license (see LICENSE for details)       *\n*                                                                              *\n********************************************************************************\n\nLDI 1       * Load the value one which will be used for subtracting.\nSTA 255\nLDI 100     * Load the starting value.\n\n            * Label the following instruction with \"loop\" which can be referenced\nloop:       * in jump instructions.\nSUB 255     * Subtract one.\nOUT         * Output the result.\nJMP loop    * Jump to the label \"loop\".\n",
  "modulo": "********************************************************************************\n*                                                                              *\n*      (c) 2018 Max Apodaca                                                    *\n*      This code is licensed under MIT license (see LICENSE for details)       *\n*                                                                              *\n********************************************************************************\n\nLDI 98       * The dividend\nSTA 255\nLDI 45        * The divisor\nSTA 254\nLDI 1         * constant one for subtraction\nSTA 253\nLDI 0         * reset accumulator to zero\nSTA 252\n\ndivide:\nLDA 255       * Load the dividend into the A register\nSUB 254       * subtract divisor\nJGZ skip      * if dividend is zero end the program\nJEZ skip\nJMP end\nskip: STA 255 * save the number\nLDA 252       * load the accumulator\nADD 253       * add one to the accumulator\nSTA 252       * save the result\nJMP divide    * repeat until divisor number to multiply is zero\n\nend:\nLDA 255       * load remaining dividend\nOUT           * output result\nHLT\n",
  "multiply": "********************************************************************************\n*                                                                              *\n*      (c) 2018 Max Apodaca                                                    *\n*      This code is licensed under MIT license (see LICENSE for details)       *\n*                                                                              *\n********************************************************************************\n\nLDI 8         * First number to multiply\nSTA 255\nLDI 8         * second number to multiply\nSTA 254\nLDI 1         * constant one for subtraction\nSTA 253\nLDI 0         * reset accumulator to zero\nSTA 252\n\nmultiply:\nLDA 255       * Load the first number to multiply into a\nJEZ end       * if it is zero end the program\nSUB 253       * subtract 1\nSTA 255       * save the number\nLDA 252       * load the accumulator\nADD 254       * add the second number to multiply\nSTA 252       * save the result\nJMP multiply  * repeat until first number to multiply is zero\n\nend:\nLDA 252       * load accumulator\nOUT           * output result\nHLT\n",
  "prime": "********************************************************************************\n*                                                                              *\n*      (c) 2018 Max Apodaca                                                    *\n*      This code is licensed under MIT license (see LICENSE for details)       *\n*                                                                              *\n********************************************************************************\n\n********************************************************************************\n*                           Prime Number Example                               *\n*                                                                              *\n*     This program computes the prime numbers in a given range. It does this   *\n*   by checking whether each number in that range is divisible by a number     *\n*   smaller than it but larger than one.                                       *\n*                                                                              *\n********************************************************************************\n\n\nLDI 1         * Start of the range to check\nSTA 255       * Store this in 255 which will be the counter for the a loop\nLDI 1         * Load the constant 1 which is used for incrementing\nSTA 254       * Address 254 will contain this value\nLDI 113       * The end of the range to check\nSTA 253       * Address 254 will be used to determine when to break out of a\n\na:            * The outer loop which iterates the numbers in the given range.\nLDA 255       * Load address 255 which contains the loop counter.\nSUB 253       * subtract the ending bound of the range, this will result in a\nJEZ end       * negative number unless the loop has reached the desired value\n              * in which case we jump.\nLDA 255       * Load the counter for the loop.\nADD 254       * Increment the counter by one.\nSTA 255       * Update the stored value of the counter\n\nLDI 2         * Load and store the starting location for the inner loop, this\nSTA 252       * is the first divisor we will use. In addition this value is used\n              * as a counter for the inner loop.\nb:\nSUB 255       * Subtract the outer loop's counter to determine if the inner loop\nJGZ aend      * should exit.\nJEZ aend\nLDA 252       * Load the inner loop counter.\nSTA 250       * Store it in memory location 250 which the modulo routine uses as\n              * the divisor.\nLDA 255       * Load the outer loop counter which will be used as the dividend.\nJMP modulo    * Jump to the modulo sequence. This will leave a modulo %250 in\n              * memory location 251. \"a\" refers to the value in the a register\n              * and \"%250\" to the value in memory address 250.\nbcont:\nLDA 251       * Load the result of a modulo %250 into the a register.\nJEZ a         * If the result is zero we know the number is not prime, therefor\n              * we jump to the next number.\nLDA 252       * Load the inner loop counter.\nADD 254       * Increment the counter by 1.\nSTA 252       * Save the new value.\nJMP b\n\naend:\nLDA 255       * Load the value that is now determined to be prime\nOUT           * Output the value\nJMP a\n\nmodulo:\nSTA 251       * Store the a register value to preserve the last known good value\nSUB 250       * subtract divisor\nJGZ modulo    * if dividend is less than zero, exit\nJEZ modulo\nJMP bcont\n\nend:\nHLT\n"
};

export default examples;
